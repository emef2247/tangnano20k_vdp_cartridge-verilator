#include "vdp_cartridge_wrapper.h"
#include "Vtangnano20k_vdp_cartridge.h"
#include "verilated.h"
#include "verilated_vcd_c.h"
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <assert.h>
#include <inttypes.h>
#include <math.h>

/* -------------------------------------------------------------------------
 * Basic state / configuration
 * -------------------------------------------------------------------------*/
#define VRAM_WORD_COUNT (1 << 17)
static uint32_t g_vram[VRAM_WORD_COUNT];

static Vtangnano20k_vdp_cartridge* g_top = nullptr;
static VerilatedVcdC* g_tfp = nullptr;

/* clock caches */
static uint8_t g_clk = 0;
static uint8_t g_clk14m = 0;

/* DUT clock parameters */
static const uint64_t MAIN_CYCLE_PS = 23270ULL;   /* 23.270 ns -> 23270 ps */
static const uint64_t HALF_CYCLE_PS = (MAIN_CYCLE_PS / 2ULL); /* 11635 ps */

/* global sim time in ps */
static uint64_t g_time_ps = 0;
static uint64_t last_dump_ps = (uint64_t)(-1);

/* SDRAM bus cache (simplified) */
static uint32_t prev_bus_address = 0;
static uint8_t prev_bus_valid = 0;
static uint8_t prev_bus_write = 0;
static uint32_t prev_bus_wdata = 0;
static uint8_t prev_bus_wdata_mask = 0;

/* write mode and debug flags */
static int g_write_on_posedge = 0;
static int g_debug_enabled = 0;

/* -------------------------------------------------------------------------
 * slot_clk emulation + auxiliary VCD writer
 * -------------------------------------------------------------------------*/

/* CPU clock (slot_clk) roughly 3.579545 MHz:
 * period ≈ (1e9 / 3_579_545) ns = ~279.355 ns = 279355 ps
 */
static const double CPU_PERIOD_PS_D = (1000000000.0 / 3579545.0) * 1000.0;
static const uint64_t CPU_HALF_PERIOD_PS = (uint64_t)floor(CPU_PERIOD_PS_D / 2.0 + 0.5);

static uint8_t g_slot_clk = 0;
static uint64_t g_next_slot_clk_toggle_ps = 0;

/* Aux VCD file for slot_clk */
static FILE* g_aux_vcd = nullptr;
static int g_aux_vcd_opened = 0;

static void aux_vcd_open(const char* path) {
    if (g_aux_vcd) return;
    g_aux_vcd = fopen(path ? path : "slot_clk.vcd", "w");
    if (!g_aux_vcd) return;
    g_aux_vcd_opened = 1;
    fprintf(g_aux_vcd, "$date\n    %s\n$end\n", "Generated by vdp wrapper");
    fprintf(g_aux_vcd, "$version\n    vdp_cartridge_wrapper slot_clk aux\n$end\n");
    fprintf(g_aux_vcd, "$timescale 1ps $end\n");
    fprintf(g_aux_vcd, "$scope module tb $end\n");
    fprintf(g_aux_vcd, "$var wire 1 s slot_clk $end\n");
    fprintf(g_aux_vcd, "$upscope $end\n");
    fprintf(g_aux_vcd, "$enddefinitions $end\n");
    fprintf(g_aux_vcd, "#0\n");
    fprintf(g_aux_vcd, "0s\n");
    fflush(g_aux_vcd);
}
static void aux_vcd_write_change(uint64_t time_ps, uint8_t v) {
    if (!g_aux_vcd_opened || !g_aux_vcd) return;
    fprintf(g_aux_vcd, "#%" PRIu64 "\n", time_ps);
    if (v) fprintf(g_aux_vcd, "1s\n"); else fprintf(g_aux_vcd, "0s\n");
    fflush(g_aux_vcd);
}
static void aux_vcd_close(void) {
    if (!g_aux_vcd) return;
    fclose(g_aux_vcd);
    g_aux_vcd = nullptr;
    g_aux_vcd_opened = 0;
}

static void slot_clk_update_if_needed(void) {
    if (!g_aux_vcd_opened) return;
    while (g_time_ps >= g_next_slot_clk_toggle_ps) {
        g_slot_clk = g_slot_clk ? 0 : 1;
        aux_vcd_write_change(g_next_slot_clk_toggle_ps, g_slot_clk);
        if (g_debug_enabled) {
            fprintf(stderr, "aux slot_clk toggle -> %d at time=%" PRIu64 "\n", g_slot_clk, g_next_slot_clk_toggle_ps);
        }
        g_next_slot_clk_toggle_ps += CPU_HALF_PERIOD_PS;
    }
}

/* -------------------------------------------------------------------------
 * Helpers
 * -------------------------------------------------------------------------*/
static inline int ns_to_cycles_ceil(int ns) {
    if (ns <= 0) return 0;
    uint64_t ns_ps = (uint64_t)ns * 1000ULL;
    return (int)((ns_ps + MAIN_CYCLE_PS - 1ULL) / MAIN_CYCLE_PS);
}

static inline void vdp_cartridge_eval_and_dump_current_time(void) {
    if (!g_top) return;
    g_top->eval();
#if VM_TRACE
    if (g_tfp) {
        if (g_time_ps != last_dump_ps) {
            g_tfp->dump(g_time_ps);
            last_dump_ps = g_time_ps;
        }
    }
#else
    (void)g_tfp;
#endif
    slot_clk_update_if_needed();
}

/* -------------------------------------------------------------------------
 * Public API
 * -------------------------------------------------------------------------*/
void vdp_cartridge_init(void) {
    if (g_top) return;
    g_top = new Vtangnano20k_vdp_cartridge();

    g_top->clk = 0;
    g_top->clk14m = 0;
    g_top->slot_reset_n = 0;
    g_top->slot_iorq_n = 1;
    g_top->slot_rd_n = 1;
    g_top->slot_wr_n = 1;
    g_top->slot_a = 0;
    g_top->slot_d = 0;
    g_top->slot_data_dir = 1;
    g_top->dipsw = 0;
    g_top->button = 0;

    g_clk = 0;
    g_clk14m = 0;
    g_time_ps = 0;
    last_dump_ps = (uint64_t)(-1);
    g_write_on_posedge = 0;
    g_debug_enabled = 0;

    g_slot_clk = 0;
    g_next_slot_clk_toggle_ps = g_time_ps + CPU_HALF_PERIOD_PS;
    aux_vcd_open("slot_clk.vcd");

    memset(g_vram, 0, sizeof(g_vram));
    g_top->eval();
}

void vdp_cartridge_release(void) {
    if (!g_top) return;
    if (g_tfp) vdp_cartridge_trace_close();
    aux_vcd_close();
    delete g_top;
    g_top = nullptr;
}

void vdp_cartridge_reset(void) {
    if (!g_top) return;
    g_top->slot_reset_n = 0;
    for (int i = 0; i < 8; ++i) {
        vdp_cartridge_step_clk_posedge();
        vdp_cartridge_step_clk_negedge();
    }
    g_top->slot_reset_n = 1;
    for (int i = 0; i < 8; ++i) {
        vdp_cartridge_step_clk_posedge();
        vdp_cartridge_step_clk_negedge();
    }
}

void vdp_cartridge_step_clk_posedge(void) {
    if (!g_top) return;
    g_clk = 1;
    g_clk14m = 1;
    g_top->clk = g_clk;
    g_top->clk14m = g_clk14m;

    vdp_cartridge_sdram_bus_eval();
    vdp_cartridge_eval_and_dump_current_time();

    g_time_ps += HALF_CYCLE_PS;
    slot_clk_update_if_needed();
}

void vdp_cartridge_step_clk_negedge(void) {
    if (!g_top) return;
    g_clk = 0;
    g_clk14m = 0;
    g_top->clk = g_clk;
    g_top->clk14m = g_clk14m;

    vdp_cartridge_sdram_bus_eval();
    vdp_cartridge_eval_and_dump_current_time();

    g_time_ps += HALF_CYCLE_PS;
    slot_clk_update_if_needed();
}

/* Note: vdpcart_step_clk_1cycle is defined inline in header file */

void vdp_cartridge_set_button(uint8_t v) { if (!g_top) return; g_top->button = (v & 0x3); }
void vdp_cartridge_set_dipsw(uint8_t v)  { if (!g_top) return; g_top->dipsw = (v & 0x3); }

void vdp_cartridge_set_write_on_posedge(int enable) { g_write_on_posedge = enable ? 1 : 0; }
void vdp_cartridge_set_debug(int enable) { g_debug_enabled = enable ? 1 : 0; }

/* -------------------------------------------------------------------------
 * SDRAM model
 * -------------------------------------------------------------------------*/
void vdp_cartridge_dram_write(uint32_t addr, uint32_t data, uint8_t mask) {
    if (addr >= VRAM_WORD_COUNT) return;
    uint32_t cur = g_vram[addr];
    for (int i = 0; i < 4; ++i) {
        if (mask & (1 << i)) ((uint8_t*)&cur)[i] = ((uint8_t*)&data)[i];
    }
    g_vram[addr] = cur;
}
uint32_t vdp_cartridge_dram_read(uint32_t addr) {
    if (addr >= VRAM_WORD_COUNT) return 0;
    return g_vram[addr];
}
void vdp_cartridge_dram_dump(FILE* fp) {
    if (!fp) fp = stdout;
    for (uint32_t i = 0; i < 16; ++i) fprintf(fp, "VRAM[%04x]=%08x\n", i, g_vram[i]);
}
void* vdp_cartridge_get_vram_buffer(void) { return (void*)g_vram; }
size_t vdp_cartridge_get_vram_size(void) { return VRAM_WORD_COUNT * sizeof(uint32_t); }

void vdp_cartridge_sdram_bus_eval(void) {
    if (!g_top) return;

    uint32_t bus_addr = g_top->O_sdram_addr;
    uint32_t bus_ba = g_top->O_sdram_ba;
    uint32_t bus_address = (bus_ba << 11) | bus_addr;
    uint32_t wdata = g_top->IO_sdram_dq;
    uint8_t  wmask = g_top->O_sdram_dqm;

    uint8_t cs_n  = g_top->O_sdram_cs_n;
    uint8_t ras_n = g_top->O_sdram_ras_n;
    uint8_t cas_n = g_top->O_sdram_cas_n;
    uint8_t we_n  = g_top->O_sdram_wen_n;

    if ((cs_n == 0) && (ras_n == 1) && (cas_n == 0) && (we_n == 0)) {
        vdp_cartridge_dram_write(bus_address, wdata, wmask);
    }
}

/* -------------------------------------------------------------------------
 * write_io implementation (negedge-mode default)
 * - re-asserts address/data every cycle while driving
 * - holds drive until slot_wait clears, then releases
 * -------------------------------------------------------------------------*/
/* Replace existing vdp_cartridge_write_io with this improved version */
void vdp_cartridge_write_io(uint16_t address, uint8_t wdata)
{
    if (!g_top) return;

    /* If posedge-mode is enabled, run a posedge-oriented multi-cycle window
     * that re-asserts address/data each cycle and holds until slot_wait clears.
     * Default is negedge-mode (tb reproduction).
     *
     * Important: DO NOT drive g_top->slot_data_dir here — that port is an OUTPUT
     * from the DUT. Instead, read g_top->slot_data_dir and drive g_top->slot_d
     * only when the DUT indicates the external CPU/slot should drive the bus
     * (slot_data_dir == 0). This matches tb.sv's assign slot_d = slot_data_dir ? ZZ : ff_slot_data.
     */
    if (g_write_on_posedge) {
        const int t_addr_ns = 170;
        const int t_wr_assert_ns = 125;
        const int t_iorq_assert_ns = 135;
        const int t_wr_deassert_ns = 120;
        const int t_iorq_deassert_ns = 145;

        int cyc_addr = ns_to_cycles_ceil(t_addr_ns);
        int cyc_wr_assert = ns_to_cycles_ceil(t_wr_assert_ns);
        int cyc_iorq_assert = ns_to_cycles_ceil(t_iorq_assert_ns);
        int cyc_wr_deassert_off = ns_to_cycles_ceil(t_wr_deassert_ns);
        int cyc_iorq_deassert_off = ns_to_cycles_ceil(t_iorq_deassert_ns);

        int cyc_wr_deassert = cyc_wr_assert + cyc_wr_deassert_off;
        int cyc_iorq_deassert = cyc_iorq_assert + cyc_iorq_deassert_off;

        if (g_debug_enabled) {
            fprintf(stderr, "vdp_write_io (posedge-mode): addr=0x%02x data=0x%02x (cyc_addr=%d cyc_wr_assert=%d cyc_iorq_assert=%d cyc_wr_deassert=%d cyc_iorq_deassert=%d)\n",
                    address & 0xFF, wdata, cyc_addr, cyc_wr_assert, cyc_iorq_assert, cyc_wr_deassert, cyc_iorq_deassert);
        }

        /* initialize control inputs (idle) */
        g_top->slot_iorq_n = 1;
        g_top->slot_wr_n   = 1;
        /* Do not touch slot_data_dir (DUT output) */
        g_top->slot_d = wdata;
        g_top->slot_a = 0;

        /* Align to posedge so our window is sampled on posedge */
        vdp_cartridge_step_clk_posedge();

        int drive_start_cycle = (cyc_addr > 3) ? (cyc_addr - 3) : 1;

        int final_cycle = cyc_iorq_deassert;
        if (cyc_wr_deassert > final_cycle) final_cycle = cyc_wr_deassert;
        if (cyc_addr > final_cycle) final_cycle = cyc_addr;
        final_cycle += 6;

        if (g_debug_enabled) {
            fprintf(stderr, "  posedge drive_start_cycle=%d final_cycle=%d (g_time_ps=%" PRIu64 ")\n",
                    drive_start_cycle, final_cycle, g_time_ps);
        }

        for (int cyc = 1; cyc <= final_cycle; ++cyc) {
            /* Before the negedge (prepare signals so next posedge samples them) */
            if (cyc >= drive_start_cycle) {
                /* Always set the address (slot_a is input to DUT) */
                g_top->slot_a = (uint8_t)(address & 0xFF);
                /* Do NOT set slot_data_dir - it's DUT output.
                 * Drive slot_d only when DUT indicates external driver is expected.
                 */
                if ((int)g_top->slot_data_dir == 0) {
                    g_top->slot_d = wdata;
                    if (g_debug_enabled) {
                        fprintf(stderr, "PRE- cycle %2d: DRIVE ON (DUT slot_data_dir==0) a=0x%02x d=0x%02x time=%" PRIu64 "\n",
                                cyc, (int)g_top->slot_a, (int)g_top->slot_d, g_time_ps);
                    }
                } else {
                    if (g_debug_enabled) {
                        fprintf(stderr, "PRE- cycle %2d: DUT drives or tri-state (slot_data_dir==1) a=0x%02x wdata=0x%02x time=%" PRIu64 "\n",
                                cyc, (int)g_top->slot_a, (int)wdata, g_time_ps);
                    }
                }
            } else {
                if (g_debug_enabled) {
                    fprintf(stderr, "PRE- cycle %2d: idle time=%" PRIu64 " slot_data_dir=%d\n",
                            cyc, g_time_ps, (int)g_top->slot_data_dir);
                }
            }

            /* control signal timing (use same cycle numbers as tb conversion) */
            if (cyc == cyc_iorq_assert) {
                g_top->slot_iorq_n = 0;
                if (g_debug_enabled) fprintf(stderr, "ACT  cycle %2d: IORQ asserted time=%" PRIu64 "\n", cyc, g_time_ps);
            }
            if (cyc == cyc_wr_assert) {
                g_top->slot_wr_n = 0;
                if (g_debug_enabled) fprintf(stderr, "ACT  cycle %2d: WR asserted time=%" PRIu64 "\n", cyc, g_time_ps);
            }
            if (cyc == cyc_wr_deassert) {
                g_top->slot_wr_n = 1;
                if (g_debug_enabled) fprintf(stderr, "ACT  cycle %2d: WR deasserted time=%" PRIu64 "\n", cyc, g_time_ps);
            }
            if (cyc == cyc_iorq_deassert) {
                g_top->slot_iorq_n = 1;
                if (g_debug_enabled) fprintf(stderr, "ACT  cycle %2d: IORQ deasserted time=%" PRIu64 "\n", cyc, g_time_ps);
            }

            /* NEGEDGE then POSEDGE to align sampling on posedge */
            vdp_cartridge_step_clk_negedge();
            if (g_debug_enabled) {
                fprintf(stderr, "POST- cycle %2d: after negedge: slot_data_dir=%d slot_a=0x%02x slot_d=0x%02x time=%" PRIu64 "\n",
                        cyc, (int)g_top->slot_data_dir, (int)g_top->slot_a, (int)g_top->slot_d, g_time_ps);
            }

            vdp_cartridge_step_clk_posedge();
            if (g_debug_enabled) {
                fprintf(stderr, "POST+ cycle %2d: after posedge: slot_data_dir=%d slot_a=0x%02x slot_d=0x%02x time=%" PRIu64 "\n",
                        cyc, (int)g_top->slot_data_dir, (int)g_top->slot_a, (int)g_top->slot_d, g_time_ps);
            }

            /* internal u_v9958 cpu-interface status (use correct generated member names) */
            if (g_debug_enabled) {
                fprintf(stderr,
                        "  INTERNAL u_v9958.u_cpu_interface: ff_register_write=%d ff_register_num=0x%02x ff_1st_byte=0x%02x ff_bus_wdata=0x%02x\n",
                        (int)g_top->tangnano20k_vdp_cartridge__DOT__u_v9958__DOT__u_cpu_interface__DOT__ff_register_write,
                        (int)g_top->tangnano20k_vdp_cartridge__DOT__u_v9958__DOT__u_cpu_interface__DOT__ff_register_num,
                        (int)g_top->tangnano20k_vdp_cartridge__DOT__u_v9958__DOT__u_cpu_interface__DOT__ff_1st_byte,
                        (int)g_top->tangnano20k_vdp_cartridge__DOT__u_v9958__DOT__u_cpu_interface__DOT__ff_bus_wdata
                );
            }
        }

        /* Keep driving until DUT clears slot_wait (do not attempt to force slot_data_dir) */
        if (g_debug_enabled) fprintf(stderr, "Waiting for DUT slot_wait to clear while still driving (posedge-mode)...\n");
        {
            int safety_count = 0;
            const int safety_limit = 1000000;
            while (g_top->slot_wait == 1) {
                /* drive only when DUT indicates external driver (slot_data_dir == 0) */
                if ((int)g_top->slot_data_dir == 0) {
                    g_top->slot_d = wdata;
                }
                vdp_cartridge_step_clk_negedge();
                vdp_cartridge_step_clk_posedge();
                if (++safety_count > safety_limit) break;
                if (g_debug_enabled && (safety_count % 100 == 0)) {
                    fprintf(stderr, "  waiting... safety_count=%d g_time_ps=%" PRIu64 " slot_data_dir=%d\n",
                            safety_count, g_time_ps, (int)g_top->slot_data_dir);
                }
            }
        }

        /* Do NOT write g_top->slot_data_dir here - it's DUT output.
         * After slot_wait clears, we simply stop driving (the DUT will tri-state or drive as intended).
         */
        if (g_debug_enabled) {
            fprintf(stderr, "POST  END (posedge-mode): done; readback slot_data_dir=%d slot_a=0x%02x slot_d=0x%02x time=%" PRIu64 "\n",
                    (int)g_top->slot_data_dir, (int)g_top->slot_a, (int)g_top->slot_d, g_time_ps);
        }

        /* final settle */
        vdp_cartridge_step_clk_negedge();
        vdp_cartridge_step_clk_posedge();

        return;
    }

    /* ----- negedge-mode (tb.sv reproduction) ----- */
    /* This is similar to original negedge-mode, but we must NOT assign slot_data_dir here.
     * Instead, we only write slot_d when DUT indicates slot_data_dir == 0.
     */
    {
        const int t_addr_ns = 170;
        const int t_wr_assert_ns = 125;
        const int t_iorq_assert_ns = 135;
        const int t_wr_deassert_ns = 120;
        const int t_iorq_deassert_ns = 145;

        int cyc_addr = ns_to_cycles_ceil(t_addr_ns);
        int cyc_wr_assert = ns_to_cycles_ceil(t_wr_assert_ns);
        int cyc_iorq_assert = ns_to_cycles_ceil(t_iorq_assert_ns);
        int cyc_wr_deassert_off = ns_to_cycles_ceil(t_wr_deassert_ns);
        int cyc_iorq_deassert_off = ns_to_cycles_ceil(t_iorq_deassert_ns);

        int cyc_wr_deassert = cyc_wr_assert + cyc_wr_deassert_off;
        int cyc_iorq_deassert = cyc_iorq_assert + cyc_iorq_deassert_off;

        if (g_debug_enabled) {
            fprintf(stderr, "vdp_write_io (negedge-mode): addr=0x%02x data=0x%02x (cyc_addr=%d cyc_wr_assert=%d cyc_iorq_assert=%d cyc_wr_deassert=%d cyc_iorq_deassert=%d)\n",
                    address & 0xFF, wdata, cyc_addr, cyc_wr_assert, cyc_iorq_assert, cyc_wr_deassert, cyc_iorq_deassert);
        }

        g_top->slot_iorq_n = 1;
        g_top->slot_wr_n   = 1;
        /* Do not touch slot_data_dir */
        g_top->slot_d = wdata;
        g_top->slot_a = 0;

        /* start at negedge so scheduled changes are seen at next posedge */
        vdp_cartridge_step_clk_negedge();

        int drive_start_cycle = (cyc_addr > 2) ? (cyc_addr - 2) : 1;

        int final_cycle = cyc_iorq_deassert;
        if (cyc_wr_deassert > final_cycle) final_cycle = cyc_wr_deassert;
        if (cyc_addr > final_cycle) final_cycle = cyc_addr;
        final_cycle += 5;

        if (g_debug_enabled) {
            fprintf(stderr, "  negedge drive_start_cycle=%d final_cycle=%d (g_time_ps=%" PRIu64 ")\n",
                    drive_start_cycle, final_cycle, g_time_ps);
        }

        for (int cyc = 1; cyc <= final_cycle; ++cyc) {
            if (cyc >= drive_start_cycle) {
                g_top->slot_a = (uint8_t)(address & 0xFF);
                /* Drive only if DUT indicates external bus driving */
                if ((int)g_top->slot_data_dir == 0) {
                    g_top->slot_d = wdata;
                    if (g_debug_enabled) {
                        fprintf(stderr, "PRE  cycle %2d: DRIVE ON (DUT slot_data_dir==0) a=0x%02x d=0x%02x time=%" PRIu64 "\n",
                                cyc, (int)g_top->slot_a, (int)g_top->slot_d, g_time_ps);
                    }
                } else {
                    if (g_debug_enabled) {
                        fprintf(stderr, "PRE  cycle %2d: DUT drives/tri-state (slot_data_dir==1) a=0x%02x wdata=0x%02x time=%" PRIu64 "\n",
                                cyc, (int)g_top->slot_a, (int)wdata, g_time_ps);
                    }
                }
            } else {
                if (g_debug_enabled) {
                    fprintf(stderr, "PRE  cycle %2d: idle time=%" PRIu64 " slot_data_dir=%d\n",
                            cyc, g_time_ps, (int)g_top->slot_data_dir);
                }
            }

            if (cyc == cyc_iorq_assert) {
                g_top->slot_iorq_n = 0;
                if (g_debug_enabled) fprintf(stderr, "ACT  cycle %2d: IORQ asserted time=%" PRIu64 "\n", cyc, g_time_ps);
            }
            if (cyc == cyc_wr_assert) {
                g_top->slot_wr_n = 0;
                if (g_debug_enabled) fprintf(stderr, "ACT  cycle %2d: WR asserted time=%" PRIu64 "\n", cyc, g_time_ps);
            }
            if (cyc == cyc_wr_deassert) {
                g_top->slot_wr_n = 1;
                if (g_debug_enabled) fprintf(stderr, "ACT  cycle %2d: WR deasserted time=%" PRIu64 "\n", cyc, g_time_ps);
            }
            if (cyc == cyc_iorq_deassert) {
                g_top->slot_iorq_n = 1;
                if (g_debug_enabled) fprintf(stderr, "ACT  cycle %2d: IORQ deasserted time=%" PRIu64 "\n", cyc, g_time_ps);
            }

            /* step one full cycle (posedge then negedge) — wrapper helpers handle eval+dump */
            vdp_cartridge_step_clk_posedge();
            if (g_debug_enabled) {
                fprintf(stderr, "POST+ cycle %2d: after posedge: slot_data_dir=%d slot_a=0x%02x slot_d=0x%02x time=%" PRIu64 "\n",
                        cyc, (int)g_top->slot_data_dir, (int)g_top->slot_a, (int)g_top->slot_d, g_time_ps);
            }

            vdp_cartridge_step_clk_negedge();
            if (g_debug_enabled) {
                fprintf(stderr, "POST- cycle %2d: after negedge: slot_data_dir=%d slot_a=0x%02x slot_d=0x%02x time=%" PRIu64 "\n",
                        cyc, (int)g_top->slot_data_dir, (int)g_top->slot_a, (int)g_top->slot_d, g_time_ps);
            }

            /* internal status */
            if (g_debug_enabled) {
                fprintf(stderr,
                        "  INTERNAL u_v9958.u_cpu_interface: ff_register_write=%d ff_register_num=0x%02x ff_1st_byte=0x%02x ff_bus_wdata=0x%02x\n",
                        (int)g_top->tangnano20k_vdp_cartridge__DOT__u_v9958__DOT__u_cpu_interface__DOT__ff_register_write,
                        (int)g_top->tangnano20k_vdp_cartridge__DOT__u_v9958__DOT__u_cpu_interface__DOT__ff_register_num,
                        (int)g_top->tangnano20k_vdp_cartridge__DOT__u_v9958__DOT__u_cpu_interface__DOT__ff_1st_byte,
                        (int)g_top->tangnano20k_vdp_cartridge__DOT__u_v9958__DOT__u_cpu_interface__DOT__ff_bus_wdata
                );
            }
        }

        /* Keep driving until DUT clears slot_wait */
        if (g_debug_enabled) fprintf(stderr, "Waiting for DUT slot_wait to clear while still driving (negedge-mode)...\n");
        {
            int safety_count = 0;
            const int safety_limit = 1000000;
            while (g_top->slot_wait == 1) {
                if ((int)g_top->slot_data_dir == 0) {
                    g_top->slot_d = wdata;
                }
                vdp_cartridge_step_clk_posedge();
                vdp_cartridge_step_clk_negedge();
                if (++safety_count > safety_limit) break;
                if (g_debug_enabled && (safety_count % 100 == 0)) {
                    fprintf(stderr, "  waiting... safety_count=%d g_time_ps=%" PRIu64 " slot_data_dir=%d\n",
                            safety_count, g_time_ps, (int)g_top->slot_data_dir);
                }
            }
        }

        if (g_debug_enabled) {
            fprintf(stderr, "POST  END (negedge-mode): done; readback slot_data_dir=%d slot_a=0x%02x slot_d=0x%02x time=%" PRIu64 "\n",
                    (int)g_top->slot_data_dir, (int)g_top->slot_a, (int)g_top->slot_d, g_time_ps);
        }

        /* final settle */
        vdp_cartridge_step_clk_posedge();
        vdp_cartridge_step_clk_negedge();
    }
}

/* -------------------------------------------------------------------------
 * Trace control & sim-time getter
 * -------------------------------------------------------------------------*/
int vdp_cartridge_trace_open(const char* path)
{
    if (!g_top) return -1;
    if (g_tfp) return 0;

    Verilated::traceEverOn(true);
    g_tfp = new VerilatedVcdC;
    g_time_ps = 0;
    last_dump_ps = (uint64_t)(-1);

#ifdef VM_TRACE
    g_top->trace(g_tfp, 99);
    g_tfp->open(path ? path : "dump.vcd");
    if (!g_aux_vcd_opened) aux_vcd_open("slot_clk.vcd");
    return 0;
#else
    delete g_tfp;
    g_tfp = nullptr;
    return -1;
#endif
}

void vdp_cartridge_trace_close(void)
{
    if (!g_tfp) return;
#ifdef VM_TRACE
    g_tfp->close();
    delete g_tfp;
    g_tfp = nullptr;
#else
    if (g_tfp) { delete g_tfp; g_tfp = nullptr; }
#endif
    if (g_aux_vcd_opened) aux_vcd_close();
}

uint64_t vdp_cartridge_get_sim_time(void)
{
    return g_time_ps;
}

uint8_t vdp_cartridge_get_slot_wait(void)
{
    if (!g_top) return 0;
    return (g_top->slot_wait ? 1 : 0);
}