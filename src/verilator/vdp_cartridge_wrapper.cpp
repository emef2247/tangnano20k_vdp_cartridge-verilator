// src/verilator/vdp_cartridge_wrapper.cpp
// Unified vdp_cartridge_wrapper.cpp with enhanced debug logging
// (based on your previous version; only logging additions and small informational prints)

#include "vdp_cartridge_wrapper.h"
#include "Vwrapper_top.h"
#include "verilated.h"
#include "verilated_vcd_c.h"
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <assert.h>
#include <inttypes.h>
#include <math.h>

/* -------------------------------------------------------------------------
 * Basic state / configuration
 * -------------------------------------------------------------------------*/
#define VRAM_WORD_COUNT (1 << 17)
static uint32_t g_vram[VRAM_WORD_COUNT];

static Vwrapper_top* g_top = nullptr;
static VerilatedVcdC* g_tfp = nullptr;

/* clock caches */
static uint8_t g_clk = 0;
static uint8_t g_clk14m = 0;

/* DUT clock parameters */
static const uint64_t MAIN_CYCLE_PS = 23270ULL;   /* 23.270 ns -> 23270 ps */
static const uint64_t HALF_CYCLE_PS = (MAIN_CYCLE_PS / 2ULL); /* 11635 ps */

/* global sim time in ps */
static uint64_t g_time_ps = 0;
static uint64_t last_dump_ps = (uint64_t)(-1);

/* Add phase tracking to detect double-calls/ordering mistakes:
   g_phase: 0 = unknown/init, 1 = last called posedge, -1 = last called negedge
*/
static int g_phase = 0;

/* SDRAM bus cache (simplified) */
static uint32_t prev_bus_address = 0;
static uint8_t prev_bus_valid = 0;
static uint8_t prev_bus_write = 0;
static uint32_t prev_bus_wdata = 0;
static uint8_t prev_bus_wdata_mask = 0;

/* write mode and debug flags */
static int g_write_on_posedge = 0;
static int g_debug_enabled = 0;

/* -------------------------------------------------------------------------
 * slot_clk emulation + auxiliary VCD writer
 * -------------------------------------------------------------------------*/

/* CPU clock (slot_clk) roughly 3.579545 MHz:
 * period â‰ˆ (1e9 / 3_579_545) ns = ~279.355 ns = 279355 ps
 */
static const double CPU_PERIOD_PS_D = (1000000000.0 / 3579545.0) * 1000.0;
static const uint64_t CPU_HALF_PERIOD_PS = (uint64_t)floor(CPU_PERIOD_PS_D / 2.0 + 0.5);

static uint8_t g_slot_clk = 0;
static uint64_t g_next_slot_clk_toggle_ps = 0;

/* Aux VCD file for slot_clk */
static FILE* g_aux_vcd = nullptr;
static int g_aux_vcd_opened = 0;

static void aux_vcd_open(const char* path) {
    if (g_aux_vcd) return;
    g_aux_vcd = fopen(path ? path : "slot_clk.vcd", "w");
    if (!g_aux_vcd) return;
    g_aux_vcd_opened = 1;
    fprintf(g_aux_vcd, "$date\n    %s\n$end\n", "Generated by vdp wrapper");
    fprintf(g_aux_vcd, "$version\n    vdp_cartridge_wrapper slot_clk aux\n$end\n");
    fprintf(g_aux_vcd, "$timescale 1ps $end\n");
    fprintf(g_aux_vcd, "$scope module tb $end\n");
    fprintf(g_aux_vcd, "$var wire 1 s slot_clk $end\n");
    fprintf(g_aux_vcd, "$upscope $end\n");
    fprintf(g_aux_vcd, "$enddefinitions $end\n");
    fprintf(g_aux_vcd, "#0\n");
    fprintf(g_aux_vcd, "0s\n");
    fflush(g_aux_vcd);
}
static void aux_vcd_write_change(uint64_t time_ps, uint8_t v) {
    if (!g_aux_vcd_opened || !g_aux_vcd) return;
    fprintf(g_aux_vcd, "#%" PRIu64 "\n", time_ps);
    if (v) fprintf(g_aux_vcd, "1s\n"); else fprintf(g_aux_vcd, "0s\n");
    fflush(g_aux_vcd);
}
static void aux_vcd_close(void) {
    if (!g_aux_vcd) return;
    fclose(g_aux_vcd);
    g_aux_vcd = nullptr;
    g_aux_vcd_opened = 0;
}

static void slot_clk_update_if_needed(void) {
    if (!g_aux_vcd_opened) return;
    while (g_time_ps >= g_next_slot_clk_toggle_ps) {
        g_slot_clk = g_slot_clk ? 0 : 1;
        aux_vcd_write_change(g_next_slot_clk_toggle_ps, g_slot_clk);
        if (g_debug_enabled) {
            fprintf(stderr, "aux slot_clk toggle -> %d at time=%" PRIu64 "\n", g_slot_clk, g_next_slot_clk_toggle_ps);
        }
        g_next_slot_clk_toggle_ps += CPU_HALF_PERIOD_PS;
    }
}

/* -------------------------------------------------------------------------
 * Helpers
 * -------------------------------------------------------------------------*/
static inline int ns_to_cycles_ceil(int ns) {
    if (ns <= 0) return 0;
    uint64_t ns_ps = (uint64_t)ns * 1000ULL;
    return (int)((ns_ps + MAIN_CYCLE_PS - 1ULL) / MAIN_CYCLE_PS);
}

/* Centralized eval + trace dump at current g_time_ps (no time advance) */
static inline void vdp_cartridge_eval_and_dump_current_time(void) {
    if (!g_top) return;
    g_top->eval();
#if VM_TRACE
    if (g_tfp) {
        if (g_time_ps != last_dump_ps) {
            g_tfp->dump(g_time_ps);
            last_dump_ps = g_time_ps;
        }
    }
#else
    (void)g_tfp;
#endif
}

/* -------------------------------------------------------------------------
 * Public API
 * -------------------------------------------------------------------------*/
void vdp_cartridge_init(void) {
    if (g_top) return;
    g_top = new Vwrapper_top();

    g_top->clk = 0;
    g_top->clk14m = 0;
    g_top->slot_reset_n = 0;
    g_top->slot_iorq_n = 1;
    g_top->slot_rd_n = 1;
    g_top->slot_wr_n = 1;
    g_top->slot_a = 0;
    /* DO NOT touch slot_d (inout) here - bridge handles it */
    g_top->slot_data_dir = 1;
    g_top->dipsw = 0;
    g_top->button = 0;

    g_clk = 0;
    g_clk14m = 0;
    g_time_ps = 0;
    last_dump_ps = (uint64_t)(-1);
    g_write_on_posedge = 0;
    g_debug_enabled = 0;

    g_slot_clk = 0;
    g_next_slot_clk_toggle_ps = g_time_ps + CPU_HALF_PERIOD_PS;
    aux_vcd_open("slot_clk.vcd");

    memset(g_vram, 0, sizeof(g_vram));
    /* use centralized eval+dump */
    vdp_cartridge_eval_and_dump_current_time();
}

void vdp_cartridge_release(void) {
    if (!g_top) return;
    if (g_tfp) vdp_cartridge_trace_close();
    aux_vcd_close();
    delete g_top;
    g_top = nullptr;
}

/* Simple reset sequence: pulse slot_reset_n low for several cycles */
void vdp_cartridge_reset(void)
{
    if (!g_top) return;

    /* Assert reset (active low) */
    g_top->slot_reset_n = 0;
    for (int i = 0; i < 8; ++i) {
        vdp_cartridge_step_clk_posedge();
        vdp_cartridge_step_clk_negedge();
    }

    /* Deassert reset and run a few cycles to stabilize */
    g_top->slot_reset_n = 1;
    for (int i = 0; i < 8; ++i) {
        vdp_cartridge_step_clk_posedge();
        vdp_cartridge_step_clk_negedge();
    }
}

/* Step helpers follow ikaopll pattern:
 *  - set clock levels
 *  - eval + dump at current time
 *  - advance g_time_ps to after-edge
 *  - update aux slot clock toggles based on new time
 *
 * Enhanced logging added (when g_debug_enabled==1):
 *  - log entry showing g_time_ps/g_clk/g_phase
 *  - log exit showing new g_time_ps and which edge executed
 */
void vdp_cartridge_step_clk_posedge(void) {
    if (!g_top) return;

    /* Entry marker (useful to correlate with waveform marker) */
    fprintf(stderr, "MARK: POS_ENTRY time=%" PRIu64 " clk=%d phase=%d\n", g_time_ps, g_clk, g_phase);

    /* Expect to be called only when previous phase was negedge (or init) */
    if (g_phase == 1) {
        if (g_debug_enabled) fprintf(stderr, "WARN: posedge called twice in a row (g_time_ps=%" PRIu64 ")\n", g_time_ps);
    }
    g_phase = 1;

    g_clk = 1;
    g_clk14m = 1;
    g_top->clk = g_clk;
    g_top->clk14m = g_clk14m;

    vdp_cartridge_eval_and_dump_current_time();

    /* advance time to the moment after this edge */
    g_time_ps += HALF_CYCLE_PS;
    slot_clk_update_if_needed();

    /* Exit marker */
    fprintf(stderr, "MARK: POS_EXIT time=%" PRIu64 " clk=%d phase=%d\n", g_time_ps, g_clk, g_phase);
}

void vdp_cartridge_step_clk_negedge(void) {
    if (!g_top) return;

    /* Entry marker */
    fprintf(stderr, "MARK: NEG_ENTRY time=%" PRIu64 " clk=%d phase=%d\n", g_time_ps, g_clk, g_phase);

    /* Expect to be called only when previous phase was posedge (or init) */
    if (g_phase == -1) {
        if (g_debug_enabled) fprintf(stderr, "WARN: negedge called twice in a row (g_time_ps=%" PRIu64 ")\n", g_time_ps);
    }
    g_phase = -1;

    g_clk = 0;
    g_clk14m = 0;
    g_top->clk = g_clk;
    g_top->clk14m = g_clk14m;

    vdp_cartridge_eval_and_dump_current_time();

    g_time_ps += HALF_CYCLE_PS;
    slot_clk_update_if_needed();

    /* Exit marker */
    fprintf(stderr, "MARK: NEG_EXIT time=%" PRIu64 " clk=%d phase=%d\n", g_time_ps, g_clk, g_phase);
}


/* Note: vdpcart_step_clk_1cycle is defined inline in header file */

void vdp_cartridge_set_button(uint8_t v) { if (!g_top) return; g_top->button = (v & 0x3); }
void vdp_cartridge_set_dipsw(uint8_t v)  { if (!g_top) return; g_top->dipsw = (v & 0x3); }

void vdp_cartridge_set_write_on_posedge(int enable) { g_write_on_posedge = enable ? 1 : 0; }
void vdp_cartridge_set_debug(int enable) { g_debug_enabled = enable ? 1 : 0; }

/* -------------------------------------------------------------------------
 * SDRAM model
 * -------------------------------------------------------------------------*/
void vdp_cartridge_dram_write(uint32_t addr, uint32_t data, uint8_t mask) {
    if (addr >= VRAM_WORD_COUNT) return;
    uint32_t cur = g_vram[addr];
    for (int i = 0; i < 4; ++i) {
        if (mask & (1 << i)) ((uint8_t*)&cur)[i] = ((uint8_t*)&data)[i];
    }
    g_vram[addr] = cur;
}
uint32_t vdp_cartridge_dram_read(uint32_t addr) {
    if (addr >= VRAM_WORD_COUNT) return 0;
    return g_vram[addr];
}
void vdp_cartridge_dram_dump(FILE* fp) {
    if (!fp) fp = stdout;
    for (uint32_t i = 0; i < 16; ++i) fprintf(fp, "VRAM[%04x]=%08x\n", i, g_vram[i]);
}
void* vdp_cartridge_get_vram_buffer(void) { return (void*)g_vram; }
size_t vdp_cartridge_get_vram_size(void) { return VRAM_WORD_COUNT * sizeof(uint32_t); }

void vdp_cartridge_sdram_bus_eval(void) {
    if (!g_top) return;

    uint32_t bus_addr = g_top->O_sdram_addr;
    uint32_t bus_ba = g_top->O_sdram_ba;
    uint32_t bus_address = (bus_ba << 11) | bus_addr;
    uint32_t wdata = g_top->IO_sdram_dq;
    uint8_t  wmask = g_top->O_sdram_dqm;

    uint8_t cs_n  = g_top->O_sdram_cs_n;
    uint8_t ras_n = g_top->O_sdram_ras_n;
    uint8_t cas_n = g_top->O_sdram_cas_n;
    uint8_t we_n  = g_top->O_sdram_wen_n;

    if ((cs_n == 0) && (ras_n == 1) && (cas_n == 0) && (we_n == 0)) {
        vdp_cartridge_dram_write(bus_address, wdata, wmask);
    }
}

/* Centralized driver: perform cycles for posedge-mode.
   - drive_start_cycle: 1-based cycle index when we begin driving
   - final_cycle: last cycle to run (inclusive)
   - cyc_wr_assert, cyc_iorq_assert, cyc_wr_deassert, cyc_iorq_deassert: cycle indices for control
*/

/* Centralized driver: perform cycles for posedge-mode.
   Emits MARK logs for each cycle pos/neg exit (with cycle index). */
static void drive_cycles_posedge_mode(int drive_start_cycle, int final_cycle,
                                      int cyc_wr_assert, int cyc_iorq_assert,
                                      int cyc_wr_deassert, int cyc_iorq_deassert,
                                      uint16_t address, uint8_t wdata)
{
    for (int cyc = 1; cyc <= final_cycle; ++cyc) {
        /* Ensure we are at negedge phase before we set signals for posedge */
        if (g_phase != -1) {
            if (g_debug_enabled) fprintf(stderr, "INFO: align to negedge before cycle %d (g_phase=%d g_time_ps=%" PRIu64 ")\n", cyc, g_phase, g_time_ps);
            vdp_cartridge_step_clk_negedge();
        }

        /* Planned-state marker (before posedge) */
        fprintf(stderr, "MARK: PLAN cycle=%2d time=%" PRIu64 " will_drive=%d addr=0x%02x data=0x%02x iorq=%d wr=%d\n",
                cyc, g_time_ps, (cyc >= drive_start_cycle), (int)(address & 0xFF), (int)wdata,
                (cyc == cyc_iorq_assert) ? 0 : 1, (cyc == cyc_wr_assert) ? 0 : 1);

        /* Set signals that should be sampled on posedge */
        if (cyc >= drive_start_cycle) {
            g_top->slot_a = (uint8_t)(address & 0xFF);
            g_top->cpu_ff_slot_data = wdata;
            g_top->cpu_drive_en = 1;
        } else {
            g_top->cpu_drive_en = 0;
        }

        /* Control assertions/deassertions for this cycle (visible at posedge) */
        if (cyc == cyc_iorq_assert) g_top->slot_iorq_n = 0;
        if (cyc == cyc_wr_assert)   g_top->slot_wr_n   = 0;
        if (cyc == cyc_wr_deassert) g_top->slot_wr_n   = 1;
        if (cyc == cyc_iorq_deassert) g_top->slot_iorq_n = 1;

        /* posedge - DUT samples values now */
        vdp_cartridge_step_clk_posedge();

        /* post-pos marker with cycle index */
        fprintf(stderr, "MARK: CYCLE_POS_EXIT cycle=%2d time=%" PRIu64 " slot_a=0x%02x slot_d=0x%02x cpu_drive_en=%d\n",
                cyc, g_time_ps, (int)g_top->slot_a, (int)g_top->slot_d, (int)g_top->cpu_drive_en);

        /* negedge - settle and finish cycle */
        vdp_cartridge_step_clk_negedge();

        /* post-neg marker */
        fprintf(stderr, "MARK: CYCLE_NEG_EXIT cycle=%2d time=%" PRIu64 " slot_a=0x%02x slot_d=0x%02x cpu_drive_en=%d\n",
                cyc, g_time_ps, (int)g_top->slot_a, (int)g_top->slot_d, (int)g_top->cpu_drive_en);
    }
}

/* -------------------------------------------------------------------------
 * write_io implementation (posedge-mode default)
 * -------------------------------------------------------------------------*/
/* Full write function with MARK logs at start/align/drive loops/wait/end.
 * This version avoids time-less force operations; it advances time only via
 * posedge/negedge step helpers (which themselves advance g_time_ps).
 */
void vdp_cartridge_write_io(uint16_t address, uint8_t wdata)
{
    if (!g_top) return;

    if (g_write_on_posedge) {
        /* WRITE-START marker */
        fprintf(stderr, "MARK: WRITE_START addr=0x%02x data=0x%02x time=%" PRIu64 " clk=%d phase=%d\n",
                address & 0xFF, wdata, g_time_ps, g_clk, g_phase);

        const int t_addr_ns = 170;
        const int t_wr_assert_ns = 125;
        const int t_iorq_assert_ns = 135;
        const int t_wr_deassert_ns = 120;
        const int t_iorq_deassert_ns = 145;

        int cyc_addr = ns_to_cycles_ceil(t_addr_ns);
        int cyc_wr_assert = ns_to_cycles_ceil(t_wr_assert_ns);
        int cyc_iorq_assert = ns_to_cycles_ceil(t_iorq_assert_ns);
        int cyc_wr_deassert_off = ns_to_cycles_ceil(t_wr_deassert_ns);
        int cyc_iorq_deassert_off = ns_to_cycles_ceil(t_iorq_deassert_ns);

        int cyc_wr_deassert = cyc_wr_assert + cyc_wr_deassert_off;
        int cyc_iorq_deassert = cyc_iorq_assert + cyc_iorq_deassert_off;

        if (g_debug_enabled) {
            fprintf(stderr, "DBG: vdp_write_io params (cyc_addr=%d wr_assert=%d iorq_assert=%d wr_deassert=%d iorq_deassert=%d) time=%" PRIu64 "\n",
                    cyc_addr, cyc_wr_assert, cyc_iorq_assert, cyc_wr_deassert, cyc_iorq_deassert, g_time_ps);
        }

        /* prepare idle */
        g_top->slot_iorq_n = 1;
        g_top->slot_wr_n   = 1;
        g_top->cpu_ff_slot_data = wdata;
        g_top->cpu_drive_en = 0;
        g_top->slot_a = 0;

        /* ALIGN: ensure we start drive cycles from a known negedge-aligned phase.
           This call's completion corresponds to the marker B/I in your logs. */
        vdp_cartridge_step_clk_negedge();
        fprintf(stderr, "MARK: ALIGN_DONE time=%" PRIu64 " clk=%d phase=%d\n", g_time_ps, g_clk, g_phase);

        int drive_start_cycle = (cyc_addr > 3) ? (cyc_addr - 3) : 1;
        int final_cycle = cyc_iorq_deassert;
        if (cyc_wr_deassert > final_cycle) final_cycle = cyc_wr_deassert;
        if (cyc_addr > final_cycle) final_cycle = cyc_addr;
        final_cycle += 6;

        /* DRIVE loop (pos-edge sampling) */
        fprintf(stderr, "MARK: DRIVE_BEGIN drive_start=%d final=%d time=%" PRIu64 "\n", drive_start_cycle, final_cycle, g_time_ps);
        drive_cycles_posedge_mode(drive_start_cycle, final_cycle,
                                  cyc_wr_assert, cyc_iorq_assert,
                                  cyc_wr_deassert, cyc_iorq_deassert,
                                  address, wdata);
        fprintf(stderr, "MARK: DRIVE_END time=%" PRIu64 " clk=%d phase=%d\n", g_time_ps, g_clk, g_phase);

        /* Wait for slot_wait, stepping pairs (pos/neg) while asserted.
           Each loop will emit step markers from the step helpers. */
        if (g_debug_enabled) fprintf(stderr, "MARK: WAIT_START checking slot_wait (time=%" PRIu64 ")\n", g_time_ps);
        {
            int safety_count = 0;
            const int safety_limit = 1000000;
            while (g_top->slot_wait == 1) {
                vdp_cartridge_step_clk_posedge();
                vdp_cartridge_step_clk_negedge();
                if (++safety_count > safety_limit) {
                    fprintf(stderr, "WARN: wait loop safety limit reached\n");
                    break;
                }
            }
        }
        if (g_debug_enabled) fprintf(stderr, "MARK: WAIT_END time=%" PRIu64 " slot_wait=%d\n", g_time_ps, (int)g_top->slot_wait);

        /* release & final eval */
        g_top->cpu_drive_en = 0;
        vdp_cartridge_eval_and_dump_current_time();

        /* ALIGN to a consistent end-phase: ensure low (clk==0) on exit */
        if (g_clk == 1) {
            fprintf(stderr, "MARK: PRE_ALIGN_END time=%" PRIu64 " clk=1 -> stepping negedge to align low\n", g_time_ps);
            vdp_cartridge_step_clk_negedge();
            fprintf(stderr, "MARK: POST_ALIGN_END time=%" PRIu64 " clk=%d phase=%d\n", g_time_ps, g_clk, g_phase);
        }

        /* WRITE-END marker */
        fprintf(stderr, "MARK: WRITE_END addr=0x%02x data=0x%02x time=%" PRIu64 " clk=%d phase=%d slot_a=0x%02x slot_d=0x%02x\n",
                address & 0xFF, wdata, g_time_ps, g_clk, g_phase, (int)g_top->slot_a, (int)g_top->slot_d);

        return;
    }

    /* ----- negedge-mode (unchanged semantics) ----- */
    {
        /* If you need the same level of markings for negedge-mode, mirror the
           MARK placements above in the negedge code path. */
        const int t_addr_ns = 170;
        const int t_wr_assert_ns = 125;
        const int t_iorq_assert_ns = 135;
        const int t_wr_deassert_ns = 120;
        const int t_iorq_deassert_ns = 145;

        int cyc_addr = ns_to_cycles_ceil(t_addr_ns);
        int cyc_wr_assert = ns_to_cycles_ceil(t_wr_assert_ns);
        int cyc_iorq_assert = ns_to_cycles_ceil(t_iorq_assert_ns);
        int cyc_wr_deassert_off = ns_to_cycles_ceil(t_wr_deassert_ns);
        int cyc_iorq_deassert_off = ns_to_cycles_ceil(t_iorq_deassert_ns);

        int cyc_wr_deassert = cyc_wr_assert + cyc_wr_deassert_off;
        int cyc_iorq_deassert = cyc_iorq_assert + cyc_iorq_deassert_off;

        fprintf(stderr, "MARK: WRITE_START_NEG addr=0x%02x data=0x%02x time=%" PRIu64 "\n", address & 0xFF, wdata, g_time_ps);

        g_top->slot_iorq_n = 1;
        g_top->slot_wr_n   = 1;
        g_top->cpu_ff_slot_data = wdata;
        g_top->cpu_drive_en = 0;
        g_top->slot_a = 0;

        /* align & drive similar to posedge but sampling on negedge */
        vdp_cartridge_step_clk_negedge();
        fprintf(stderr, "MARK: ALIGN_DONE_NEG time=%" PRIu64 "\n", g_time_ps);

        int drive_start_cycle = (cyc_addr > 2) ? (cyc_addr - 2) : 1;
        int final_cycle = cyc_iorq_deassert;
        if (cyc_wr_deassert > final_cycle) final_cycle = cyc_wr_deassert;
        if (cyc_addr > final_cycle) final_cycle = cyc_addr;
        final_cycle += 5;

        for (int cyc = 1; cyc <= final_cycle; ++cyc) {
            if (cyc >= drive_start_cycle) {
                g_top->slot_a = (uint8_t)(address & 0xFF);
                g_top->cpu_ff_slot_data = wdata;
                g_top->cpu_drive_en = 1;
            } else {
                g_top->cpu_drive_en = 0;
            }

            if (cyc == cyc_iorq_assert) g_top->slot_iorq_n = 0;
            if (cyc == cyc_wr_assert)   g_top->slot_wr_n   = 0;
            if (cyc == cyc_wr_deassert) g_top->slot_wr_n   = 1;
            if (cyc == cyc_iorq_deassert) g_top->slot_iorq_n = 1;

            /* sample on negedge */
            vdp_cartridge_step_clk_negedge();
            fprintf(stderr, "MARK: CYCLE_NEG_SAMPLED cycle=%2d time=%" PRIu64 " slot_a=0x%02x slot_d=0x%02x\n",
                    cyc, g_time_ps, (int)g_top->slot_a, (int)g_top->slot_d);

            /* posedge settle */
            vdp_cartridge_step_clk_posedge();
            fprintf(stderr, "MARK: CYCLE_POS_SETTLE cycle=%2d time=%" PRIu64 "\n", cyc, g_time_ps);
        }

        /* wait/publish/align end */
        while (g_top->slot_wait == 1) {
            vdp_cartridge_step_clk_posedge();
            vdp_cartridge_step_clk_negedge();
        }

        g_top->cpu_drive_en = 0;
        vdp_cartridge_eval_and_dump_current_time();

        if (g_clk == 1) {
            vdp_cartridge_step_clk_negedge();
        }

        fprintf(stderr, "MARK: WRITE_END_NEG addr=0x%02x data=0x%02x time=%" PRIu64 "\n", address & 0xFF, wdata, g_time_ps);
        return;
    }
}

/* -------------------------------------------------------------------------
 * Trace control & sim-time getter
 * -------------------------------------------------------------------------*/
int vdp_cartridge_trace_open(const char* path)
{
    if (!g_top) return -1;
    if (g_tfp) return 0;

    Verilated::traceEverOn(true);
    g_tfp = new VerilatedVcdC;
    g_time_ps = 0;
    last_dump_ps = (uint64_t)(-1);

#ifdef VM_TRACE
    g_top->trace(g_tfp, 99);
    g_tfp->open(path ? path : "dump.vcd");
    if (!g_aux_vcd_opened) aux_vcd_open("slot_clk.vcd");
    return 0;
#else
    delete g_tfp;
    g_tfp = nullptr;
    return -1;
#endif
}

void vdp_cartridge_trace_close(void)
{
    if (!g_tfp) return;
#ifdef VM_TRACE
    g_tfp->close();
    delete g_tfp;
    g_tfp = nullptr;
#else
    if (g_tfp) { delete g_tfp; g_tfp = nullptr; }
#endif
    if (g_aux_vcd_opened) aux_vcd_close();
}

uint64_t vdp_cartridge_get_sim_time(void)
{
    return g_time_ps;
}

uint8_t vdp_cartridge_get_slot_wait(void)
{
    if (!g_top) return 0;
    return (g_top->slot_wait ? 1 : 0);
}