// Updated vdp_cartridge_wrapper.cpp (excerpted/complete) adapted to wrapper_top
// Key changes:
//  - Top type changed to Vwrapper_top
//  - Drive the bridge via cpu_ff_slot_data / cpu_drive_en instead of writing slot_d directly
//  - Adjusted internal FF readback member paths to wrapper_top__DOT__u_dut__DOT__...
//
// Save this file over your existing src/verilator/vdp_cartridge_wrapper.cpp
// (this file is a complete replacement for the wrapper; keep your other helper APIs).

#include "vdp_cartridge_wrapper.h"
#include "Vwrapper_top.h"                 // generated by Verilator when top = wrapper_top
#include "verilated.h"
#include "verilated_vcd_c.h"
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <assert.h>
#include <inttypes.h>
#include <math.h>

/* -------------------------------------------------------------------------
 * Basic state / configuration
 * -------------------------------------------------------------------------*/
#define VRAM_WORD_COUNT (1 << 17)
static uint32_t g_vram[VRAM_WORD_COUNT];

static Vwrapper_top* g_top = nullptr;      // NOTE: changed top type
static VerilatedVcdC* g_tfp = nullptr;

/* clocks and timing same as before */
static const uint64_t MAIN_CYCLE_PS = 23270ULL;
static const uint64_t HALF_CYCLE_PS = (MAIN_CYCLE_PS / 2ULL);

static uint64_t g_time_ps = 0;
static uint64_t last_dump_ps = (uint64_t)(-1);

static int g_write_on_posedge = 0;
static int g_debug_enabled = 0;

/* slot_clk aux VCD code unchanged... (keep your existing aux_vcd_ helpers) */
/* ... (omitted here for brevity in this block) ... */
/* You can reuse the previous aux_vcd_open/aux_vcd_write_change/slot_clk_update_if_needed
   implementations from your current wrapper file. */

/* Helpers (ns_to_cycles_ceil, vdp_cartridge_eval_and_dump_current_time, etc.)
   can be reused from your existing wrapper implementation. */

/* Initialization */
void vdp_cartridge_init(void) {
    if (g_top) return;
    g_top = new Vwrapper_top();

    /* ensure known initial inputs */
    g_top->clk = 0;
    g_top->clk14m = 0;
    g_top->slot_reset_n = 0;
    g_top->slot_iorq_n = 1;
    g_top->slot_rd_n = 1;
    g_top->slot_wr_n = 1;
    g_top->slot_a = 0;
    /* DO NOT touch slot_d (inout) here */
    g_top->slot_data_dir = 1; /* output from DUT; do not drive in C++ */
    g_top->dipsw = 0;
    g_top->button = 0;

    g_time_ps = 0;
    last_dump_ps = (uint64_t)(-1);
    g_write_on_posedge = 0;
    g_debug_enabled = 0;

    /* Initialize the CPU-side bridge signals (explicit) */
    g_top->cpu_ff_slot_data = 0;
    g_top->cpu_drive_en = 0;

    /* slot-clock aux init if used */
    // aux_vcd_open("slot_clk.vcd");

    memset(g_vram, 0, sizeof(g_vram));
    g_top->eval();
}

/* Release */
void vdp_cartridge_release(void) {
    if (!g_top) return;
    if (g_tfp) vdp_cartridge_trace_close();
    // aux_vcd_close();
    delete g_top;
    g_top = nullptr;
}

/* Step helpers (posedge/negedge) â€” reuse existing implementations,
   but they must call g_top->eval() and trace/dump as before. */

/* ---------- write_io (adapted) ----------
 * Instead of driving g_top->slot_d directly, we set:
 *   g_top->cpu_ff_slot_data = wdata;
 *   g_top->cpu_drive_en = 1;  // start driving bridge
 * and later set cpu_drive_en = 0 to release.
 *
 * We also read internal DUT flags via wrapper_top__DOT__u_dut__DOT__...
 */
void vdp_cartridge_write_io(uint16_t address, uint8_t wdata)
{
    if (!g_top) return;

    /* If posedge-mode is enabled, run a posedge-oriented multi-cycle window */
    if (g_write_on_posedge) {
        /* same timing conversions as before */
        const int t_addr_ns = 170;
        const int t_wr_assert_ns = 125;
        const int t_iorq_assert_ns = 135;
        const int t_wr_deassert_ns = 120;
        const int t_iorq_deassert_ns = 145;

        int cyc_addr = ns_to_cycles_ceil(t_addr_ns);
        int cyc_wr_assert = ns_to_cycles_ceil(t_wr_assert_ns);
        int cyc_iorq_assert = ns_to_cycles_ceil(t_iorq_assert_ns);
        int cyc_wr_deassert_off = ns_to_cycles_ceil(t_wr_deassert_ns);
        int cyc_iorq_deassert_off = ns_to_cycles_ceil(t_iorq_deassert_ns);

        int cyc_wr_deassert = cyc_wr_assert + cyc_wr_deassert_off;
        int cyc_iorq_deassert = cyc_iorq_assert + cyc_iorq_deassert_off;

        if (g_debug_enabled) {
            fprintf(stderr, "vdp_write_io (posedge-mode): addr=0x%02x data=0x%02x (cyc_addr=%d cyc_wr_assert=%d cyc_iorq_assert=%d cyc_wr_deassert=%d cyc_iorq_deassert=%d)\n",
                    address & 0xFF, wdata, cyc_addr, cyc_wr_assert, cyc_iorq_assert, cyc_wr_deassert, cyc_iorq_deassert);
        }

        /* Initialize control inputs (idle) */
        g_top->slot_iorq_n = 1;
        g_top->slot_wr_n = 1;
        /* Do not touch slot_data_dir here; it's an output of the DUT */

        /* Prepare drive via bridge: set CPU-side bus value, but don't enable yet */
        g_top->cpu_ff_slot_data = wdata;
        g_top->cpu_drive_en = 0;

        /* Align to posedge so our window is sampled on posedge */
        vdp_cartridge_step_clk_posedge();

        int drive_start_cycle = (cyc_addr > 3) ? (cyc_addr - 3) : 1;
        int final_cycle = cyc_iorq_deassert;
        if (cyc_wr_deassert > final_cycle) final_cycle = cyc_wr_deassert;
        if (cyc_addr > final_cycle) final_cycle = cyc_addr;
        final_cycle += 6;

        if (g_debug_enabled) {
            fprintf(stderr, "  posedge drive_start_cycle=%d final_cycle=%d (g_time_ps=%" PRIu64 ")\n",
                    drive_start_cycle, final_cycle, g_time_ps);
        }

        /* Main loop */
        for (int cyc = 1; cyc <= final_cycle; ++cyc) {
            /* If within drive window, assert bridge drive enable for cycles where DUT expects CPU to drive.
             * Here we assert cpu_drive_en = 1 when cyc >= drive_start_cycle; the DUT will see slot_d
             * driven by the bridge. This avoids writing the DUT's inout from C++ directly.
             */
            if (cyc >= drive_start_cycle) {
                g_top->slot_a = (uint8_t)(address & 0xFF);
                g_top->cpu_ff_slot_data = wdata;
                g_top->cpu_drive_en = 1; /* bridge drives slot_d this cycle */
                if (g_debug_enabled) {
                    fprintf(stderr, "PRE- cycle %2d: bridge DRIVE_EN=1 a=0x%02x cpu_ff_slot_data=0x%02x time=%" PRIu64 "\n",
                            cyc, (int)g_top->slot_a, (int)g_top->cpu_ff_slot_data, g_time_ps);
                }
            } else {
                g_top->cpu_drive_en = 0;
                if (g_debug_enabled) {
                    fprintf(stderr, "PRE- cycle %2d: idle cpu_drive_en=0 time=%" PRIu64 "\n", cyc, g_time_ps);
                }
            }

            if (cyc == cyc_iorq_assert) {
                g_top->slot_iorq_n = 0;
                if (g_debug_enabled) fprintf(stderr, "ACT  cycle %2d: IORQ asserted time=%" PRIu64 "\n", cyc, g_time_ps);
            }
            if (cyc == cyc_wr_assert) {
                g_top->slot_wr_n = 0;
                if (g_debug_enabled) fprintf(stderr, "ACT  cycle %2d: WR asserted time=%" PRIu64 "\n", cyc, g_time_ps);
            }
            if (cyc == cyc_wr_deassert) {
                g_top->slot_wr_n = 1;
                if (g_debug_enabled) fprintf(stderr, "ACT  cycle %2d: WR deasserted time=%" PRIu64 "\n", cyc, g_time_ps);
            }
            if (cyc == cyc_iorq_deassert) {
                g_top->slot_iorq_n = 1;
                if (g_debug_enabled) fprintf(stderr, "ACT  cycle %2d: IORQ deasserted time=%" PRIu64 "\n", cyc, g_time_ps);
            }

            /* NEGEDGE then POSEDGE steps */
            vdp_cartridge_step_clk_negedge();
            if (g_debug_enabled) {
                fprintf(stderr, "POST- cycle %2d: after negedge: cpu_drive_en=%d slot_a=0x%02x cpu_ff_slot_data=0x%02x time=%" PRIu64 "\n",
                        cyc, (int)g_top->cpu_drive_en, (int)g_top->slot_a, (int)g_top->cpu_ff_slot_data, g_time_ps);
            }

            vdp_cartridge_step_clk_posedge();
            if (g_debug_enabled) {
                fprintf(stderr, "POST+ cycle %2d: after posedge: cpu_drive_en=%d slot_a=0x%02x slot_d=0x%02x time=%" PRIu64 "\n",
                        cyc, (int)g_top->cpu_drive_en, (int)g_top->slot_a, (int)g_top->slot_d, g_time_ps);
            }

            /* Read internal CPU interface of u_dut for debug (note wrapper_top -> u_dut nesting) */
            if (g_debug_enabled) {
                fprintf(stderr,
                        "  INTERNAL u_dut.u_v9958.u_cpu_interface: ff_register_write=%d ff_register_num=0x%02x ff_1st_byte=0x%02x ff_bus_wdata=0x%02x\n",
                        (int)g_top->wrapper_top__DOT__u_dut__DOT__u_v9958__DOT__u_cpu_interface__DOT__ff_register_write,
                        (int)g_top->wrapper_top__DOT__u_dut__DOT__u_v9958__DOT__u_cpu_interface__DOT__ff_register_num,
                        (int)g_top->wrapper_top__DOT__u_dut__DOT__u_v9958__DOT__u_cpu_interface__DOT__ff_1st_byte,
                        (int)g_top->wrapper_top__DOT__u_dut__DOT__u_v9958__DOT__u_cpu_interface__DOT__ff_bus_wdata
                );
            }
        }

        /* Release bridge drive and finish */
        g_top->cpu_drive_en = 0;
        if (g_debug_enabled) fprintf(stderr, "Waiting for DUT slot_wait to clear while still driving (posedge-mode)...\n");
        {
            int safety_count = 0;
            const int safety_limit = 1000000;
            while (g_top->slot_wait == 1) {
                /* don't force release; only step clocks */
                vdp_cartridge_step_clk_negedge();
                vdp_cartridge_step_clk_posedge();
                if (++safety_count > safety_limit) break;
                if (g_debug_enabled && (safety_count % 100 == 0)) {
                    fprintf(stderr, "  waiting... safety_count=%d g_time_ps=%" PRIu64 "\n", safety_count, g_time_ps);
                }
            }
        }

        /* Clear cpu_drive_en just to be explicit */
        g_top->cpu_drive_en = 0;

        if (g_debug_enabled) {
            fprintf(stderr, "POST  END (posedge-mode): done; readback cpu_drive_en=%d slot_a=0x%02x slot_d=0x%02x time=%" PRIu64 "\n",
                    (int)g_top->cpu_drive_en, (int)g_top->slot_a, (int)g_top->slot_d, g_time_ps);
        }

        vdp_cartridge_step_clk_negedge();
        vdp_cartridge_step_clk_posedge();
        return;
    }

}